[
  {
    "name": "1-basic",
    "sections": [
      {
        "name": "1-introduction",
        "content": "<div><p>Axii is a frontend framework based on reactive data structures. Its main features are:</p>\n<ul>\n<li>When reactive data structures receive dependency changes, they don't recalculate completely, but automatically use more efficient incremental computation updates. This provides significant performance improvements in many array computations.</li>\n<li>Precise updates of DOM structure and attributes by identifying reactive data. No Virtual DOM, no diff process.</li>\n</ul>\n<p>Axii aims to ensure high performance for developers in most scenarios without requiring extra effort.</p></div>"
      },
      {
        "name": "2-reactive_data_and_dynamic_part",
        "content": "<div><p>The reactive data structures in Axii include the following types:</p>\n<ul>\n<li>atom: Atomic data that is treated as a whole.</li>\n<li>RxList/RxMap/RxSet: Reactive collection data structures that emit signals when the collection changes, but changes within the collection objects are not deeply reactive.</li>\n<li>RxTime: A special reactive data structure for handling time.</li>\n</ul>\n<p>We can pass an atom to any DOM attribute, and when the atom's value changes, the DOM attribute will automatically update.\nWe can also map an RxList to a DOM array, and when the RxList's value changes, the DOM array will automatically update.</p>\n<p>Even if you're using RxMap/RxSet, they have corresponding toList methods that can convert them to RxList, allowing you to map them to DOM arrays.</p>\n<p>For more dynamic requirements, you can directly pass a function to represent the DOM structure that needs to be generated.</p></div>"
      },
      {
        "name": "3-component",
        "content": "<div><p>Axii Component Features:</p>\n<ul>\n<li>Supports default value creation. In scenarios where reactivity is not needed, regular values can be passed in, and the framework will automatically convert them.</li>\n<li>Internal DOM elements or child components can be exposed through explicit naming, eliminating unnecessary encapsulation.</li>\n</ul>\n<p>At this point, you're ready to happily use Axii!</p></div>"
      }
    ]
  },
  {
    "name": "2-advanced",
    "sections": [
      {
        "name": "1-computed",
        "content": "<div><p>Reactive data is a core concept in axii.\nThere are three ways to create reactive data:</p>\n<ul>\n<li>Using the APIs of RxList/RxMap/RxSet to create reactive data. Most calculations in APIs are incremental, which means when dependencies change, it won't recalculate everything but only make minimal incremental changes. Using APIs should be the first consideration.</li>\n<li>Using the constructors of RxList/RxMap/RxSet to create reactive data. When passing computation logic as parameters to the constructor, any change in dependencies within the computation logic will trigger a recalculation.</li>\n<li>Using computed to create atom-type reactive data. Any change in dependencies will trigger a recalculation.</li>\n</ul></div>"
      },
      {
        "name": "2-RxList_RxSet_RxMap",
        "content": "<div><p>RxList/RxMap/RxSet are built-in reactive data structures in axii.\nTheir APIs are similar to JavaScript's Array/Map/Set.\nFor more detailed examples, please refer to their test cases.</p>\n<ul>\n<li><a href=\"https://github.com/sskyy/data0/blob/main/__tests__/rxList.spec.ts\">RxList</a></li>\n<li><a href=\"https://github.com/sskyy/data0/blob/main/__tests__/rxMap.spec.ts\">RxMap</a></li>\n<li><a href=\"https://github.com/sskyy/data0/blob/main/__tests__/rxSet.spec.ts\">RxSet</a></li>\n</ul></div>"
      },
      {
        "name": "3-component_AOP",
        "content": "<div><p>In axii, we often encapsulate complex UIs into individual components and then compose them. However, sometimes the simple nesting structure can cause trouble:</p>\n<ul>\n<li>Certain DOM elements or specific properties inside a child component need to be exposed for the parent to configure or use.</li>\n<li>If we keep passing props through each layer, we end up with lots of “meaningless” intermediate wrappers, making the component tree more complicated.</li>\n</ul>\n<p>To address this, axii offers an \"AOP-like\" capability allowing you to directly penetrate child components from the parent, flexibly <strong>overwriting</strong> or <strong>patching</strong> the internal DOM or child components. This lets us maintain component encapsulation while still allowing property and event passthrough as needed, with minimal boilerplate.</p>\n<h2>Core Idea</h2>\n<p>Within axii’s implementation, <code>ComponentHost</code> parses the props you pass to a component. If a prop key starts with <code>$</code>, axii considers it an <strong>infiltration</strong> or <strong>aspect-oriented</strong> configuration aimed at the child component or DOM element, rather than a normal prop for the component itself.</p>\n<p>In these “infiltration” props, the portion after the colon (<code>:</code>) indicates which attribute or method is being applied. For example:</p>\n<ul>\n<li><code>$xxx:style</code> means: apply the inline <code>style</code> property to the DOM/child component labeled <code>as=\"xxx\"</code>.</li>\n<li><code>$xxx:value</code> means: set the <code>value</code> (usually for an <code>&lt;input&gt;</code> or similar component) for <code>as=\"xxx\"</code>.</li>\n<li><code>$xxx:style_</code> indicates you can define a custom merging strategy for style, rather than a simple deep-merge or override.</li>\n<li><code>$xxx:children</code> replaces the children of the corresponding node.</li>\n<li><code>$xxx:_props</code> applies a custom merging logic to all the props of an internal node or child component.</li>\n</ul>\n<p>In the source code, these <code>$</code>-prefixed props are collected and merged into <code>itemConfig</code>. Eventually, when rendering, <code>ComponentHost</code> applies all these rules to the relevant DOM nodes or child components. Consequently, you can do something like this in the parent component:</p>\n<pre><code class=\" language-typescript\"><span class=\" pl-s\"><span class=\" pl-sr\"><span class=\" pl-pds\">/</span> @jsx createElement <span class=\" pl-pds\">/</span></span></span>\n<span class=\" pl-k\">import</span> { <span class=\" pl-smi\">atom</span>, <span class=\" pl-smi\">RenderContext</span> } <span class=\" pl-k\">from</span> <span class=\" pl-s\"><span class=\" pl-pds\">\"</span>axii<span class=\" pl-pds\">\"</span></span>\n<span class=\" pl-k\">import</span> { <span class=\" pl-smi\">Child</span> } <span class=\" pl-k\">from</span> <span class=\" pl-s\"><span class=\" pl-pds\">\"</span>./Child.js<span class=\" pl-pds\">\"</span></span>;\n<span class=\" pl-k\">export</span> <span class=\" pl-k\">function</span> <span class=\" pl-en\">App</span>({}, { <span class=\" pl-v\">createElement</span> }<span class=\" pl-k\">:</span> <span class=\" pl-en\">RenderContext</span>) {\n    <span class=\" pl-k\">const</span> <span class=\" pl-c1\">name</span> <span class=\" pl-k\">=</span> <span class=\" pl-en\">atom</span>(<span class=\" pl-s\"><span class=\" pl-pds\">'</span>world<span class=\" pl-pds\">'</span></span>)\n    <span class=\" pl-k\">return</span> (\n        <span class=\" pl-k\">&lt;</span><span class=\" pl-v\">Child</span>\n            <span class=\" pl-c\">// Add inline style to the element labeled \"as=root\" in the child component</span>\n            <span class=\" pl-v\">$root</span><span class=\" pl-k\">:</span><span class=\" pl-en\">style</span><span class=\" pl-k\">=</span>{{ <span class=\" pl-en\">display</span>: <span class=\" pl-s\"><span class=\" pl-pds\">'</span>flex<span class=\" pl-pds\">'</span></span>, <span class=\" pl-en\">flexDirection</span>: <span class=\" pl-s\"><span class=\" pl-pds\">'</span>column<span class=\" pl-pds\">'</span></span>, <span class=\" pl-en\">alignItems</span>: <span class=\" pl-s\"><span class=\" pl-pds\">'</span>center<span class=\" pl-pds\">'</span></span> }}\n            <span class=\" pl-c\">// Bind an atom to the &lt;input&gt; element labeled \"as=main\"</span>\n            <span class=\" pl-v\">$main</span><span class=\" pl-k\">:</span><span class=\" pl-en\">value</span><span class=\" pl-k\">=</span>{<span class=\" pl-smi\">name</span>}\n            <span class=\" pl-c\">// Customize merge logic via style_</span>\n            <span class=\" pl-v\">$main</span><span class=\" pl-k\">:</span><span class=\" pl-en\">style_</span><span class=\" pl-k\">=</span>{() =&gt; ({ <span class=\" pl-en\">border</span>: <span class=\" pl-s\"><span class=\" pl-pds\">'</span>1px solid black<span class=\" pl-pds\">'</span></span>, <span class=\" pl-en\">padding</span>: <span class=\" pl-s\"><span class=\" pl-pds\">'</span>10px<span class=\" pl-pds\">'</span></span> })}\n            <span class=\" pl-c\">// Provide further configurations for the \"grandChild\" node</span>\n            <span class=\" pl-smi\">$grandChild</span><span class=\" pl-k\">=</span>{{\n                <span class=\" pl-s\"><span class=\" pl-pds\">'</span>$root:style<span class=\" pl-pds\">'</span></span>: { color: <span class=\" pl-s\"><span class=\" pl-pds\">'</span>cyan<span class=\" pl-pds\">'</span></span> }\n            }}\n        <span class=\" pl-k\">/&gt;</span>\n    )\n}\n</code></pre>\n<p>In this way, if a child component <code>Child</code> has multiple nodes labeled with <code>as=\"root\"</code>, <code>as=\"main\"</code>, <code>as=\"grandChild\"</code>, etc., the parent only needs to define <code>$root:xxx</code>, <code>$main:xxx</code>, <code>$grandChild:xxx</code>, etc. to directly pass or override the specific DOM/child component’s attributes.</p>\n<p>In the <code>Child</code> component, you might write:</p>\n<pre><code class=\" language-tsx\">\n/ @jsx createElement /\nimport { RenderContext } from \"axii\";\nimport { GrandChild } from \"./GrandChild.js\";\nexport function Child({}, { createElement }: RenderContext) {\n    return (\n        &lt;div as=\"root\"&gt;\n            &lt;input as=\"main\" /&gt;\n            &lt;button as=\"trigger\"&gt;Submit&lt;/button&gt;\n            &lt;GrandChild as=\"grandChild\" /&gt;\n        &lt;/div&gt;\n    )\n}\n</code></pre>\n<p>And in <code>GrandChild</code>:</p>\n<pre><code class=\" language-tsx\">/ @jsx createElement /\nimport { RenderContext } from \"axii\";\nexport function GrandChild({}, { createElement }: RenderContext) {\n    return (\n        &lt;div as=\"root\"&gt;\n            this is grand child\n        &lt;/div&gt;\n    )\n}\n</code></pre>\n<p>The final result is:</p>\n<ul>\n<li>The configurations for <code>$root:style</code>, <code>$main:value</code>, <code>$main:style_</code>, and <code>$grandChild</code> in <code>App</code> merge into the corresponding DOM elements/child components.</li>\n<li>Neither <code>Child</code> nor <code>GrandChild</code> needs any extra props or prop drilling; they only mark the nodes that require infiltration with <code>as=\"xxx\"</code>.</li>\n</ul>\n<h2>How It Works Under the Hood</h2>\n<p>This mechanism mainly relies on the implementation in <code>ComponentHost</code>:</p>\n<ol>\n<li>When the component is rendered, axii creates a <code>ComponentHost</code> object to manage the component’s props, render context, and lifecycle.</li>\n<li>The props are split so that everything starting with <code>$</code> is recognized as an <strong>infiltration/autonomous config</strong> (also called “component AOP”).</li>\n<li>Such infiltration configs get merged into <code>itemConfig</code>, forming a list of requirements like “apply which attribute to the node labeled as=xxx.” For example:\n<ul>\n<li><code>use</code>: fully replace that element with an existing DOM element.</li>\n<li><code>props</code>: combine these attributes into that DOM or child component.</li>\n<li><code>eventTarget</code>, <code>_use</code>, <code>_props</code>, etc. similarly follow the same principle.</li>\n</ul>\n</li>\n<li>When generating DOM or child components, <code>ComponentHost</code> looks at the merged configuration and applies the relevant props or event bindings.</li>\n</ol>\n<p>Hence, in a parent component, you can “slice in” your logic to a child component’s internal DOM or child components without passing props through each layer or writing dedicated pass-through code in the child.</p>\n<h2>More Examples and Notes</h2>\n<ol>\n<li>\n<p><strong>Avoid naming collisions</strong><br>\nIf you label a DOM element or child component with <code>as=\"root\"</code> in the child, the parent’s infiltration config must be <code>$root:xxx</code>. Make sure different nodes have unique, meaningful <code>as</code> labels.</p>\n</li>\n<li>\n<p><strong>Use custom merge logic</strong></p>\n<ul>\n<li><code>$xxx:style_={() =&gt; {...}}</code> indicates further control over merging styles.</li>\n<li><code>$xxx:[prop]_</code> can also do something similar, letting you apply a custom merge function for specific props.</li>\n</ul>\n</li>\n<li>\n<p><strong>Nested composition</strong><br>\nIf the parent sets <code>$grandChild</code> and inside it references <code>$root</code>, axii continues merging it into the corresponding nodes of <code>GrandChild</code>. This can go multiple levels deep.</p>\n</li>\n<li>\n<p><strong>Reserved for the component’s own Props</strong><br>\n<code>$xxx:xxx</code> is used only for infiltration into child nodes. If your component itself has props like <code>foo={atomValue}</code>, the normal props remain valid for your component—it will not be overridden by infiltration logic.</p>\n</li>\n<li>\n<p><strong>Flexible node replacement or reuse</strong><br>\nIf you provide a DOM element directly to <code>use</code>, you can completely replace the internal node, which might be useful for advanced scenarios such as replacing the default DOM in a child with your own DOM or an element from a third-party library.</p>\n</li>\n</ol>\n<h2>Summary</h2>\n<p>With this infiltration (AOP-like) mechanism, axii lets users configure a child component’s internal DOM elements or sub-components directly from the parent, or even “patch in” logic that would otherwise reside in the child component itself. This provides a more flexible component usage experience, keeping encapsulation while making customization a lot easier. It drastically reduces overhead from typical patterns (such as frequent prop hoisting or callback passing in React).</p>\n<p>This “component AOP” approach isn’t meant for every situation. <strong>If normal props are sufficient, prefer the standard interface to keep the component encapsulated.</strong> But if you need deeper modifications in certain places, this mechanism can save a lot of redundant prop passing, letting the parent “penetrate” the child component and apply highly specific customizations.</p></div>"
      },
      {
        "name": "4-component_context",
        "content": "<div><p>Like other frameworks, axii allows data to be passed through context.</p></div>"
      },
      {
        "name": "5-styling_transition_and_animation",
        "content": ""
      },
      {
        "name": "6-sideEffect",
        "content": "<div><p>axii supports using useEffect and useLayoutEffect to create side effects.</p>\n<p>Additionally, axii provides a more elegant way to handle side effects.\nUsers can declare a class that inherits from ManualCleanup and implement the destroy method. Any ManualCleanup subclass instantiated in a component will automatically call the destroy method when the component is destroyed.</p></div>"
      },
      {
        "name": "7-create_reactive_data_from_dom_attr",
        "content": "<div><p>DOM states are not reactive, and we often need to:</p>\n<ul>\n<li>Listen to state changes through event callbacks.</li>\n<li>Transform data changes into DOM state changes through APIs.</li>\n</ul>\n<p>axii provides reactive wrappers for commonly used DOM states, and users can also customize DOM state reactive wrappers using createStateFromRef.\nExisting wrappers include:</p>\n<ul>\n<li>dom size</li>\n<li>position</li>\n<li>drag position</li>\n<li>scroll position</li>\n</ul></div>"
      },
      {
        "name": "8-portal",
        "content": "<div><p>axii supports rendering components under different root nodes, commonly used in scenarios like popups.</p></div>"
      },
      {
        "name": "9-selection",
        "content": "<div><p>axii provides built-in tools for creating single and multiple selections, ensuring that not all rows recalculate their selected state when selection changes. This maintains high performance at all times.</p></div>"
      }
    ]
  },
  {
    "name": "3-common_util",
    "sections": [
      {
        "name": "1-router",
        "content": ""
      },
      {
        "name": "2-action",
        "content": ""
      }
    ]
  }
]